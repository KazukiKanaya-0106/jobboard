// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: nodes.sql

package repo

import (
	"context"
)

const createNode = `-- name: CreateNode :one
INSERT INTO nodes (
  cluster_id, node_name, node_token_hash
) VALUES (
  $1, $2, $3
)
RETURNING id, cluster_id, node_name, node_token_hash, current_job_id, created_at
`

type CreateNodeParams struct {
	ClusterID     string `json:"cluster_id"`
	NodeName      string `json:"node_name"`
	NodeTokenHash string `json:"node_token_hash"`
}

func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, createNode, arg.ClusterID, arg.NodeName, arg.NodeTokenHash)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.NodeName,
		&i.NodeTokenHash,
		&i.CurrentJobID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteNodeByCluster = `-- name: DeleteNodeByCluster :execrows
DELETE FROM nodes
WHERE id = $1 AND cluster_id = $2
`

type DeleteNodeByClusterParams struct {
	ID        int64  `json:"id"`
	ClusterID string `json:"cluster_id"`
}

func (q *Queries) DeleteNodeByCluster(ctx context.Context, arg DeleteNodeByClusterParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNodeByCluster, arg.ID, arg.ClusterID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getNodeByNodeTokenHash = `-- name: GetNodeByNodeTokenHash :one
SELECT id, cluster_id, node_name, node_token_hash, current_job_id, created_at
FROM nodes
WHERE node_token_hash = $1
LIMIT 1
`

func (q *Queries) GetNodeByNodeTokenHash(ctx context.Context, nodeTokenHash string) (Node, error) {
	row := q.db.QueryRow(ctx, getNodeByNodeTokenHash, nodeTokenHash)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.NodeName,
		&i.NodeTokenHash,
		&i.CurrentJobID,
		&i.CreatedAt,
	)
	return i, err
}

const listNodesByCluster = `-- name: ListNodesByCluster :many
SELECT id, cluster_id, node_name, node_token_hash, current_job_id, created_at
FROM nodes
WHERE cluster_id = $1
ORDER BY node_name ASC
`

func (q *Queries) ListNodesByCluster(ctx context.Context, clusterID string) ([]Node, error) {
	rows, err := q.db.Query(ctx, listNodesByCluster, clusterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Node{}
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.ID,
			&i.ClusterID,
			&i.NodeName,
			&i.NodeTokenHash,
			&i.CurrentJobID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNodeCurrentJob = `-- name: UpdateNodeCurrentJob :one
UPDATE nodes
SET current_job_id = $2
WHERE id = $1
RETURNING id, cluster_id, node_name, node_token_hash, current_job_id, created_at
`

type UpdateNodeCurrentJobParams struct {
	ID           int64  `json:"id"`
	CurrentJobID *int64 `json:"current_job_id"`
}

func (q *Queries) UpdateNodeCurrentJob(ctx context.Context, arg UpdateNodeCurrentJobParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNodeCurrentJob, arg.ID, arg.CurrentJobID)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.NodeName,
		&i.NodeTokenHash,
		&i.CurrentJobID,
		&i.CreatedAt,
	)
	return i, err
}
